--DDL: 커밋 하지 않아도 즉시 반영됨(=삭제하면 복구 불가, COMMIT, ROLLBAKC 없음)
--테이블 생성시 철자등 오타 확인, DB의 데이터 크기는 타이트하게 잡아야 좋음.
CREATE TABLE EMP_DDL(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10), -- = VARIABLE CHARICTOR 1O BYTE / 전화, 주민번호 - CHAR가 좋음
    JOB VARCHAR2(9),
    MGR NUMBER(4),
    HIREDATE DATE,
    SAL NUMBER(7,2), -- = 급여 7자리 중 2자리 실수표기 하겠다는 뜻. 정수는 5자리
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2)
);

INSERT INTO EMP_DDL VALUES(9000, '이서', '아이돌', 9000, SYSDATE, 10000, 2000, 10);
INSERT INTO EMP_DDL VALUES(1000, '은혁', '아이돌', 9000, SYSDATE, 10000, 2000, 10);
INSERT INTO EMP_DDL VALUES(9000, '규현', '아이돌', 9000, SYSDATE, 10000, 2000, 10);
INSERT INTO EMP_DDL VALUES(9001, '조규성', '선수', 9000, SYSDATE, 10000, 2000, 10);INSERT INTO EMP_DDL VALUES(9002, '손흥민', '토트넘', 9000, SYSDATE, 10000, 2000, 10);
INSERT INTO EMP_DDL VALUES(9003, '한선수', '배구', 9000, SYSDATE, 10000, 2000, 10);
INSERT INTO EMP_DDL VALUES(9004, '정유미', '배우', 9000, SYSDATE, 10000, 2000, 10, '+82010-1111-2222');
INSERT INTO EMP_DDL VALUES(9005, '이정재', '배우', 9000, SYSDATE, 10000, 2000, 10, '+8210-1122-2233');
INSERT INTO EMP_DDL VALUES(9006, '정우성', '배우', 9000, SYSDATE, 10000, 2000, 10, '+8210-1111-2222');



COMMIT;


--변경할때 사용하는 테이블 ALTER의 4가지
--ADD: 테이블에 열을 추가 / RENAME: 열의 이름 변경 / MODIFY: 열의 데이터 형 변경 / DROP: 열을 제거함

--테이블 열 추가 :ADD
ALTER TABLE EMP_DDL
    ADD HP VARCHAR2(20);

--테이블 열 이름 변경 :RENAME
ALTER TABLE EMP_DDL
    RENAME COLUMN HP TO TEL;

--테이블 열의 자료형 변경 :MODIFY
ALTER TABLE EMP_DDL
    MODIFY TEL VARCHAR2(15);

ALTER TABLE EMP_DDL
    MODIFY DEPTNO NUMBER(4);

--테이블 특정 열 제거(데이터가 있어도 지워지니 주의 필요) :DROP
ALTER TABLE EMP_DDL
    DROP COLUMN TEL;
    
--테이블 이름을 변경 :RENAME
RENAME EMP_DDL TO EMP_RENAME;

--테이블 모든 데이터를 삭제하는 TRUNCATE, DELETE
TRUNCATE TABLE EMP_RENAME; --DDL 명령어:껍데기만 남기고 다지움 / ROLLBACK 안됨
DELETE FROM EMP_RENAME; --DML 명령어:껍데기만 다지움 / ROLLVACK 됨
--WHERE 조건은 DELETE절만 가능, TRUNKCATE(한줄로 끝남)에는 불가능

SELECT * FROM EMP_RENAME;

--제약조건 [NOT NULL/UNIQUE/PRIMARY KEY/FOREIGN KEY/ CHECK]

--빈 값을 허용하지 않는 NOT NULL
CREATE TABLE TABLE_NOTNULL(
    LOGIN_ID VARCHAR2(20) NOT NULL,
    LOGIN_PW VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
);

INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PW, TEL) VALUES('HHB0000', 'HHHBBB111', NULL);
INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PW, TEL) VALUES('HHB1111', 'HHHBBB222', '010-1111-1111');
INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PW, TEL) VALUES('YYYWAYYY', 'WEEEEEEE123', '010-2222-1111');

--중복되지 않는 값: UNIQUE, NULL을 허용함, 테이블 내 여러 열에 존재 가능

DROP TABLE TABLE_UNIQUE;

CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR2(20) PRIMARY KEY,
    LOGIN_PW VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
);
CREATE TABLE TABLE_UNIQUE(
    LOGIN_ID VARCHAR2(20) UNIQUE NOT NULL, --유니크이면서 NOT NULL, PRIMARY KEY와 같으나, 인덱스 등록이 안됨. 테이블당 여러개 등록 가능. = 실제 동작은 프라이머리 키와 비슷하지만 다름.
    LOGIN_PW VARCHAR2(20) NOT NULL,
    TEL VARCHAR2(20)
);

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PW, TEL) VALUES('HHB1234', 'HHBB1212', NULL);
--ERROR at line 83:
--ORA-00001: unique constraint (SCOTT.SYS_C007017) violated 유니크 제약조건 위반(중복 안됨.)
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PW, TEL) VALUES(NULL, 'HHBB1212', NULL);--안넣을 땐 여러개 가능

SELECT * FROM TABLE_UNIQUE;

--외래키:다른 테이블과 관계를 맺는 FOREIGN KEY. 외래키는 서로 다른 테이블 간 관계를 정의하는데 사용하는 제약조건
--참조하고 있는 기본키의 데이터타입과 일치해야 하며(어딘가의 기본키 이기 때문에) 외래키에 참조되는 기본키는 삭제할 수 없음.
--제약조건 걸려있는걸 풀어야 테이블을 지울 수 있음(제약조건)

CREATE TABLE DEPT_FK (
    DEPTNO      NUMBER(2) PRIMARY KEY,
    DNAME       VARCHAR2(14),
    LOC         VARCHAR2(13)
);
CREATE TABLE EMP_FK (
    EMPNO   NUMBER(4) PRIMARY KEY,
    ENAME   VARCHAR2(10) NOT NULL,
    JOB     VARCHAR2(9),
    MGR     NUMBER(4),
    SAL     NUMBER(7,2),
    COMM    NUMBER(7,2),
    DEPTNO NUMBER(2) REFERENCES DEPT_FK(DEPTNO) --참조키
);

INSERT INTO DEPT_FK VALUES(10, '농구부', '서울');
INSERT INTO EMP_FK VALUES(9000, '강백호', '농구', 8000, 2300, 1200, 10);
INSERT INTO EMP_FK VALUES(9001, '한선수', '배구', 8000, 2300, 1200, 20);

SELECT * FROM
EMP_FK E JOIN DEPT_FK D
ON E.DEPTNO = D.DEPTNO;

SELECT* FROM DEPT_FK;
SELECT* FROM EMP_FK;

--데이터 형태와 범위를 정하는 CHECK
--EX) ID와 PASSWARD의 길이를 제한
--EX) 유효값 범위 반환(나이/성적/전화번호/이메일) !범위 체크! = 자바에서 정규식으로 걸 수 있음.
CREATE TABLE TABLE_CHECK (
    LOGIN_ID VARCHAR2(20) PRIMARY KEY,
    LOGIN_PW VARCHAR2(20) CHECK(LENGTH(LOGIN_PW) >= 5),
    TEL      VARCHAR2(20)
);

INSERT INTO TABLE_CHECK VALUES('HHBB12', '123456', '010-1111-1111');

--DEFAULT 제약조건: 특정열에 저장할 값이 지정되지 않는 경우, 기본값을 지정 
CREATE TABLE TABLE_DEFAULT(
    LOGIN_ID VARCHAR2(20) PRIMARY KEY,
    LOGIN_PW VARCHAR2(20) CHECK(LENGTH(LOGIN_PW) >= 5),
    TEL VARCHAR2(15) DEFAULT '010-0000-0000'
);
DROP TABLE TABLE_DAFAULT;
INSERT INTO TABLE_DEFAULT(LOGIN_ID, LOGIN_PW) VALUES('HHB2102', '0HHBHB123');


SELECT* FROM TABLE_DEFAULT;


--시퀀스란? 오라클에서 특정 규칙에 맞는 연속적인 숫자를 생성하는 객체
CREATE TABLE DEPT_SEQ(
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13)
);

CREATE SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 10 --한번에 얼마만큼 증가시킬 것인지, 증가값
START WITH 10 -- 시작값
MAXVALUE 90 --최대값
MINVALUE 0 --최소값
NOCYCLE --NOCYCLE이면 번호생성이 중단되고, 추가번호 생성시 오류.
CACHE 2; --시퀀스가 생성할 번호를 메모리에 미리 할댕해 놓은 수를 지정. NOCACHE는 미리 생성하지 않도록 지정

INSERT INTO DEPT_SEQ VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');
SELECT* FROM DEPT_SEQ;

-- ## VO(Value Object)

-- VO는 데이터베이스에서 가져온 레코드를 자바 객체로 매핑하는 데 사용됩니다. VO 객체는 데이터베이스 테이블의 각 컬럼에 해당하는 멤버 변수를 갖습니다. VO 객체를 사용하면 데이터베이스에서 가져온 레코드를 객체화하여 다양한 처리를 수행할 수 있습니다. 보여지는 정보. 

-- ## DAO(Database Access Object)

-- DAO는 데이터베이스에 접근하여 데이터를 조회하거나 수정하는 데 사용됩니다. DAO는 VO 객체와 데이터베이스 간의 매핑을 담당하며, VO 객체를 이용하여 데이터베이스의 레코드를 조회하거나 수정합니다.



SELECT *
FROM EMP;
INSERT INTO EMP VALUES(9003, '이수현', '악뮤', 9001, '20/SEP/2023', 2000, 200, 10);
INSERT INTO EMP VALUES(9004, '이수현', '악뮤', 9001, '20/SEP/2023', 2000, 200, 10);